{"version":3,"file":"checkout.js","sources":["analytics/logger.js"],"names":[],"mappings":"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","sourcesContent":["/**** Module Info\n{\n  'name': 'Logger',\n  'summary': 'Used to dynamically collect events and ship off to endpoint',\n  'keywords': ['logs', 'analytics', 'events'],\n  'settings': [\n    {\n      'name': 'Third Party Analytics Plugins',\n      'path': ['logging', 'thirdPartyTargets'],\n      'summary': 'Callbacks to fork all log payload arrays into when flushing',\n      'description': 'Should be either excluded entirely or an array of \\\n      callbacks to fork data running through the flusher. Used for things \\\n      like adapters for Omniture and Google Analytics.',\n      'input': 'textarea',\n      'validation': 'function',\n      'array': true,\n      'optional': true\n    }\n  ]\n}\n****/\n\n\ndefine('analytics/logger',[], function() {\n  return function(logConfigs) {\n    //// These are all of the public handles\n    this.eventStorage = [];\n    this.log = logEvent;\n    //// End public handles\n\n    // Alias some libraries\n    var\n      stringify = JSON.stringify,\n      lastFlush = 0,\n      // Bank of base64 charaters to use in random, near-unique id generation\n      base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n        'abcdefghijklmnopqrstuvwxyz0123456789+/',\n      // cookie polyfill\n      cookie = {\n        get: function(id) {\n          var hash;\n          document.cookie.replace(new RegExp('cmpr-'+id+'=([^;]+)'),\n            function(fullStr, match) {\n              hash = match;\n            });\n          return hash || (function(size) {\n            var base = [];\n            while (size--)\n              base.push(base64Chars[Math.floor(Math.random() * 64)]);\n            return base.join('');\n          })(32);\n        },\n        set: function(id, hash, expires) {\n          document.cookie = ['cmpr-'+id+'=', hash, ';expires=',\n            (expires || new Date(Date.now()+365*24*3600000))].join('');\n        }\n      },\n      once = function(callback) {\n        var done;\n        return function(param) {\n          done || callback(param);\n          done = 1;\n        };\n      },\n      // Set up private queue for unsent events \n      eventQueue = [],\n      // Store URL for logging backend\n      loggingTarget = loggingTarget = [location.protocol, '//', logConfigs.url].join(''),\n      // Set bool flag for if we use a debug dumper to console\n      isDebugging = /debug=true/.test(location.href),\n      // Allow storage for third party analytics API adapter function(s)\n      thirdPartyTargets = function(events) {\n        var eventSize = events.length,\n          targetSize = (logConfigs.thirdPartyTargets || []).length,\n          ii = 0, jj;\n        for (; ii < eventSize; ii++)\n          for (jj = 0; jj < targetSize; jj++)\n            logConfigs.thirdPartyTargets[jj](events[ii]);\n      },\n      // flushQueue method is debounced event sender\n      flushQueue = function(){\n        var now = new Date().getTime();\n        if (lastFlush + 250 < now){\n          sendEvents();\n          lastFlush = now;\n        }\n      };\n      // Set the $CMPR.uid\n      cookie.set('uid', $CMPR.uid = cookie.get('uid'));\n      // Set the $CMPR.sessid either based on the existing session or a 32 char one\n      cookie.set('sessid', $CMPR.sessid = cookie.get('sessid'), '0');\n\n    function appendGif(logBuffer, i) {\n      for (i = 0; i < logBuffer.length; i++) {\n        if (stringify(logBuffer.slice(0, i+1)).length > 2000)\n          break;\n      }\n      if (i === 0)\n        return false;\n      var body = document.getElementsByTagName('body')[0];\n      img = document.createElement('img');\n      img.src = loggingTarget + '?payload=' + stringify(logBuffer.splice(0, i));\n      img.style.display = 'none';\n      body.insertBefore(img, body.firstChild);\n      logBuffer.length && appendGif(logBuffer);\n      img.parentNode.removeChild(img);\n    }\n\n    function sendEvents() {\n      // Clone array of events in queue\n      var payload = eventQueue.slice(0);\n      // Empty the queue\n      eventQueue = [];\n      // If there's a location to try flushing to...\n      if (loggingTarget)\n        // Recursive call to send off the logs\n        appendGif(payload);\n      else\n        // If no target, store events local, inspectable at $CMPR.logs()\n        this.eventStorage = this.eventStorage.concat(payload);\n      // In any case, try hitting the third parties with our payload\n      setTimeout(function(){\n        thirdPartyTargets(payload);\n      }, 0);\n    }\n\n\n    /**\n     * Builds log channels which store data from log events into... channels\n     *\n     * @param {String} eventName [, {function} decoration]\n     * @return {function} Params passed and decorated if decorator included\n     */\n    function log(eventName, decoration) {\n      // Bind logger to this Logger instance scope\n      return function(data) {\n        // Build decorated object out of data, coercing to array\n        var decorated = (function(datum) {\n          var logData = {\n            // references free variable channel name from generator param\n            event: eventName,\n            // Stamp with UNIX epoch time in milliseconds\n            time: new Date().getTime(),\n            // Use analytics session id\n            cmprSessionId: $CMPR.sessid || 'No session',\n            // Use cookie id we grabbed\n            userId: $CMPR.uid || 'No user ID',\n            // Decorate data or pass over it,  empty object if no data\n            data: (decoration || function() {\n              return arguments.length > 1 ? [].slice.call(arguments, 0) : arguments[0];\n            })(datum) || {}\n          };\n          return logData;\n        })(data);\n        // Check the debug flag we got from GET param regex /debug=true/\n        isDebugging && window.console && console.log && console.log(decorated);\n        // Add all the events into the queue we periodically flush\n        eventQueue = eventQueue.concat(decorated);\n        // Try flushing the queue (may be deferred if a lot is happening)\n        flushQueue();\n        // Return data back so you can chain off curried calls in normal code\n        return data;\n      // Our binding to the log closure's scope\n      };\n    }\n\n    function logEvent(eventName, decoration) {\n      return log(eventName, decoration);\n    }\n\n    window.$CMPRSANITIZE$ = function() {\n      for(var key in window)\n        if (/^\\$CMPR.*\\$$/.test(key))\n          delete window[key];\n    };\n\n  };\n});\n\n"]}